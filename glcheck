#!/usr/bin/env node
///////////////////////////////////////////////////////////////////////////////////
// The MIT License (MIT)
//
// Copyright (c) 2019 Tarek Sherif
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
///////////////////////////////////////////////////////////////////////////////////

"use strict";


const puppeteer = require("puppeteer");
const pti = require("puppeteer-to-istanbul");
const http = require("http");
const fs = require("fs").promises;
const path = require("path");
const glob = require("glob").sync;
const copydir = require("copy-dir").sync;
const rimraf = require("rimraf").sync;

//////////////////
// CONFIGURATION
//////////////////


const GLTEST_PKG = require(path.resolve(__dirname, "package.json"));
const HELP_MESSAGE = `usage: glcheck [--help] [--version] [--config PATH] [--coverage {true/false}] 
              [--headless {true/false}] [--server-port PORT] [--output-dir PATH] 
              [--asset-dir PATH]

Test WebGL 1 and 2 applications.

Optional arguments:
  --help                    Show this help message and exit.
  --version                 Show program's version number and exit.
  --config PATH             Path to config file (default: ./glcheck.config.json)
  --coverage {true/false}   Generate coverage results that can be consumed by Istanbul [default: false].
  --headless {true/false}   Run headless [default: true].
  --server-port PORT        Port to run testing server on [default: 7171].
  --output-dir PATH         Path to output results to [default: ./glcheck-results].
  --asset-dir PATH          Path to copy assets from.
`;

let config = {
    outputDir: "glcheck-results/",
    serverPort: 7171,
    tests: [],
    assetDir: null,
    coverage: false,
    coverageExcludeFiles: [],
    headless: true
};

const argv = process.argv.slice(2);
const argc = argv.length;
const args = {};

for (let i = 0; i < argc; ++i) {
    let [ flag, arg ] = argv[i].split("=");

    switch(flag) {
        case "--config":
            args.configPath = arg || argv[++i];
            break;
        case "--coverage":
            arg = arg || argv[++i];
            args.coverage = arg.toLowerCase() !== "false";
            break;
        case "--headless":
            arg = arg || argv[++i];
            args.headless = arg.toLowerCase() !== "false";
            break;
        case "--server-port":
            args.serverPort = parseInt(arg || argv[++i], 10);
            break;
        case "--output-dir":
            args.outputDir = arg || argv[++i];
            break;
        case "--asset-dir":
            args.assetDir = arg || argv[++i];
            break;
        case "--self-test":
            args.selfTest = true;
            break;
        case "--clear-config":
            args.clearConfig = true;
            break;
        case "--version":
            console.log(GLTEST_PKG.version);
            process.exit(0);
            break;
        case "--help":
            console.log(HELP_MESSAGE);
            process.exit(0);
            break;
        default: 
            if (flag[0] === "-") {
                console.log(`Unknown flag: ${flag}`);
                process.exit(1);
            } else {
                args.tests = args.tests || [];
                args.tests.push(flag);
            }
    }
}

const configPath = path.resolve(".", args.configPath || "glcheck.config.json");

try {
    Object.assign(config, require(configPath));
    config.tests = config.tests || [];
    config.coverageExcludeFiles = config.coverageExcludeFiles || [];
    if (!Array.isArray(config.tests)) {
        config.tests = [ config.tests ];
    }
    if (!Array.isArray(config.coverageExcludeFiles)) {
        config.coverageExcludeFiles = [ config.coverageExcludeFiles ];
    }
} catch (e) {
    if (args.configPath) {
        console.log(`\u001b[31mError: Config file '${args.configPath}' not found.\u001b[0m\n`);
        process.exit(1);
    }
}

if (args.clearConfig) {
    config = { 
        tests: [],
        coverageExcludeFiles: []
    };
}

if (config.tests.length > 0 && args.tests) {
    console.log("\u001b[33mWarning: Tests from config file overriden by command line argument.\u001b[0m\n");
}

Object.assign(config, args);



const SELF_TEST = Boolean(args.selfTest);
const OUTPUT_DIR = path.resolve(".", config.outputDir);
const ASSET_DIR = path.resolve(OUTPUT_DIR, "assets");
const COVERAGE_DIR = path.resolve(".", ".nyc_output");
const CWD = process.cwd();
const BASE_URL = `http://localhost:${config.serverPort}/`;


/////////////////
// LOCAL SERVER
/////////////////

const MIME_TYPES = {
    ".css": "text/css",
    ".html": "text/html",
    ".js": "text/javascript",
    ".json": "application/json",
    ".txt": "text/plain",
    ".jpeg": "image/jpeg",
    ".jpg": "image/jpeg",
    ".png": "image/png",
    ".gif": "image/gif",
    ".bmp": "image/bmp",
    ".mov": "video/quicktime",
    ".mpeg": "video/mpeg",
    ".mpg": "video/mpeg",
    ".ogv": "video/ogg"
};

const coverageExcludeFiles = config.tests.concat(config.coverageExcludeFiles);
const EXCLUDE_REGEX = [];
coverageExcludeFiles.forEach(ex => {
    glob(ex).map(f => {
        const excludePath = path.resolve(".", f).replace(CWD, "");
        EXCLUDE_REGEX.push(new RegExp(`${excludePath}$`));
    }); 
});

const server = http.createServer(async (req, res) => {
    const url = req.url; 
    const requestPath = decodeURI(url.replace(/^\/+/, "").replace(/\?.*$/, ""));
    const filePath = path.resolve(".", requestPath);
    const mimeType = MIME_TYPES[path.extname(filePath)] || "application/octet-stream";

    const content = await fs.readFile(filePath);
    res.setHeader("Content-Type", mimeType);
    res.end(content);
}).listen(config.serverPort);

//////////////
// RUN TESTS
//////////////

(async () => {

    ///////////////////////////////
    // COPY FILES INTO OUTPUT DIR
    ///////////////////////////////

    const [ template, qunit, glcheck ] = await Promise.all([
        fs.readFile(path.resolve(__dirname, "page/index-template.html"), "utf8"),
        fs.readFile(path.resolve(__dirname, "page/qunit-2.9.2.js"), "utf8"),
        fs.readFile(path.resolve(__dirname, "page/glcheck.js"), "utf8")
    ]); 
    const testPaths = [];
    config.tests.forEach(t => {
        glob(t).map(f => {
            const modulePath = path.resolve(".", f).replace(CWD, "");
            testPaths.push(`import "${modulePath}";`);
        });
    });

    let index = template
        .replace("QUNIT_IMPORT", qunit)
        .replace("GLTEST_IMPORT", SELF_TEST ? "<script src=\"./glcheck.js\"></script>" : `<script>${glcheck}</script>`)
        .replace("FRAMEWORK_IMPORTS", testPaths.join("\n"));

    rimraf(OUTPUT_DIR);
    rimraf(COVERAGE_DIR);
    await fs.mkdir(OUTPUT_DIR);

    const writes = [ fs.writeFile(path.resolve(OUTPUT_DIR, "index.html"), index) ];

    if (config.assetDir) {
        writes.push(fs.mkdir(ASSET_DIR));
    }

    if (SELF_TEST) {
        // Include glcheck.js as external script so it shows up in coverage reports
        writes.push(fs.writeFile(path.resolve(OUTPUT_DIR, "glcheck.js"), glcheck));
    }

    await Promise.all(writes);

    if (config.assetDir) {
        copydir(path.resolve(".", config.assetDir), ASSET_DIR);
    }

    /////////////////////
    // LAUNCH PUPPETEER
    /////////////////////

    const browser = await puppeteer.launch({headless: config.headless});
    const page = await browser.newPage();

    // Report errors from the page
    page.on("console", msg => {
        if (msg.type() === "error") {
            console.log(`\u001b[31m${msg.text()}\u001b[0m\n`);
        }
    });

    page.on("pageerror", error => {
        console.log(`\u001b[31m${error.message}\u001b[0m\n`);

        server.close();
        browser.close();

        process.exit(1);
    });

    // Report results per test
    let numTests = 0;
    let numAssertions = 0;
    const testEndPromise = page.exposeFunction("glcheck_testEnd", async (test) => {
        const assertions = test.assertions;
        const count = assertions.length;
        if (count === 0) {
            return;
        }
        numTests++;
        numAssertions += count;
        if (test.status === "passed") {
            console.log(`\u001b[32mPass:\u001b[0m ${test.name}`);
        } else {
            for (let j = 0; j < count; ++j) {
                const assertion = assertions[j];
                if (!assertion.passed) {
                    console.log(`\n\u001b[31mFail:\u001b[0m ${test.name}: ${assertion.message}`);
                    console.log(`    ${assertion.negative ? "Did not expect:" : "Expected: "}\u001b[32m ${JSON.stringify(assertion.expected)}\u001b[0m`);
                    console.log(`    Got:${" ".repeat(assertion.negative ? 11 : 6)}\u001b[31m ${JSON.stringify(assertion.actual)}\u001b[0m\n`);
                    console.log(assertion.stack);
                    console.log("\n");
                }
            }
        }
    });

    // Report final results
    const runEndPromise = page.exposeFunction("glcheck_runEnd", async (results) => {
        console.log(`\nRan ${numTests} tests (${numAssertions} assertions)...\n`);

        const passed = results.status === "passed";
        if (passed) {
            console.log("\u001b[32mAll tests passed!\u001b[0m\n");
        } else {
            console.log(`\t\u001b[31m${results.testCounts.failed} tests failed.\u001b[0m\n\n`);
        }

        if (config.coverage) {
            const jsCoverage = await page.coverage.stopJSCoverage();
            pti.write(jsCoverage.filter(item => {
                const url = item.url;

                // Filter out scripts embedded in index.html
                // (i.e. test runner scripts)
                if (url.match(/\/index\.html$/)) {
                    return false;
                }

                // Filter out test files and files
                // excluded by config
                let include = true;
                EXCLUDE_REGEX.forEach(ex => {
                    if (url.match(ex)) {
                        include = false;
                    }
                });

                return include; 
            }));
        }

        await Promise.all([
            server.close(),
            browser.close()
        ]);
        
        process.exit(passed ? 0 : 1);
    });

    const pageStartPromises = [ testEndPromise, runEndPromise ];

    if (config.coverage) {
        pageStartPromises.push(page.coverage.startJSCoverage());
    }

    await Promise.all(pageStartPromises);
    
    page.goto(`${BASE_URL}${config.outputDir}/index.html`);
})();

